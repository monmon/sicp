* make-machineがやること
    * 計算機モデルを作る
        1. 全てのレジスタ計算機に、共通な計算機モデルの部品を構成する
            * そのためにmake-new-machineを呼ぶ
        2. make-new-machineで構成される基本計算機モデルを特定の計算機のレジスタ、演算、制御器を含むように拡張する
            * 渡されたレジスタ名のそれぞれに新しい計算機のレジスタを割り当て、指示された演算を計算機に組み込む
            * アセンブラを使い、制御器のリストを新しい計算機の命令に変換し、これを計算機の命令列として食い込む
        3. 修正した計算機モデルをその値として返す

* 計算機モデル
    * 局所状態を持つ手続き

* make-new-machine
    * いくつかのレジスタとスタックの容器と、制御器の命令を一つずつ処理する実行機構

* レジスタ
    * 局所状態を持つ手続き
    * make-registerで作れる

* make-register
    * アクセスしたり、変更したりできる値を保持するレジスタを作り出す

* スタック
    * 局所状態を持つ手続き

* make-stack
    * スタックの項目のリストが局所状態になっているスタックを作り出す
    * 項目をスタックにpushする、最上の項目をスタックから外して返してpopする、またスタックを空にinitializeする、要求を受け入れる

* 基本計算機
    * make-new-machine手続きを呼び出すと作られる

* make-new-machine
    * スタック、（最初は空の）命令列、（最初はスタックを初期化する）命令を含む演算のリスト、（最初はflagとpcという2つのレジスタを含む）レジスタ表、を局所状態とする
    * 内部手続きallocate-register
        * レジスタ表に新しい項目を追加
    * 内部手続きlookup-register
        * 表中のレジスタを探す
    * flagレジスタ
        * シミュレートされる計算機で分岐を制御するのに使う
    * test命令
        * flagの内容をテストの結果(真または偽)に設定する
    * branch命令
        * flagの内容を調べ、分岐するしないを決定する
    * pcレジスタ
        * 計算機が走る時の命令の進行（内部手続きexecuteが実装したもの）を制御する

「シミュレーションモデルでは, 各機械命令は, 命令実行手続き(instruction execution procedure)という, その手続きの呼出しがその命令の実行をシミュレートすることになる, 引数のない手続きを含むデータ構造である.」

* 命令と命令実行手続き
    * 命令は命令実行手続きを持つ？

* pc
    * 実行すべき次の命令から始る命令列の場所を指す

* execute
    * pcが指した命令を取り、その命令実行手続きを呼び出してそれを実行
    * pcが命令列の終わりを指すまで繰り返す


